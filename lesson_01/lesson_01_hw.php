<?php

// 1. В чем заключается суть ключевого слова global? Когда его применение целесообразно?
// Мой ответ: суть заключается в использовании объявленной вне функции переменной внутри функциии.
// Применение целесообразно когда по каким-то причинам невозможно передать переменную функции как аргумент.
// Правильный ответ: совпадает c моим.

// 2. Какие суперглобальные переменные вы знаете?
// Мой ответ: $_POST, $_GET, $_SERVER, $_SESSION, $_FILES
// Правильный ответ: $GLOBALS, $_SERVER, $_GET, $_POST, $_FILES, $_COOKIE, $_SESSION, $_REQUEST, $_ENV

// 3. Когда нужно использовать закрывающий дескриптор “?\>“?
// Мой ответ: когда после него идет код на другом языке (например HTML).
// Правильный ответ: совпадает с моим.

// 4. Что выведет программа в каждом случае и почему?
function changeX($x) {
    $x += 5;
    echo $x;
}
$x = 1;
echo $x;
changeX($x);
echo $x;
// Мой ответ: выведет 1, 6, 1. Первый вывод: глобальная переменная, инициализированная на 1
// Второй вывод: изнутри функции, аргумент, измененный на 18 строке
// Третий вывод: та же неизменившаяся глобальная переменная.
// Правильный ответ: совпадает с моим

// 5. Что выведет программа в каждом случае и почему?
function test()
{
    static $a = 0;
    echo $a;
    $a++;
}
test();
test();
test();
// Мой ответ: выведет 0, 1, 2, так как статиская переменная сохраняет свое значение между вызовами.
// Правильный ответ: совпадает с моим

// 6. Как перевернуть массив? Есть массив array(‘h’, ‘e’, ‘l’, ‘l’, ‘o’), как из него получить array(‘o’, ‘l’, ‘l’, ‘e’, ‘h’)?
// Мой ответ: это можно сделать при помощи цикла for, идущего с конца:
$arr = ['h', 'e', 'l', 'l', 'o'];
$newArr = [];
for ($i = count($arr) - 1; $i >= 0; $i--) { 
    $newArr[] = $arr[$i];
}
var_dump($newArr);
// Правильный ответ: использовать array_reverse()

// 7. Как перевернуть строку задом наперед?
// Мой ответ: разбить строку на массив по символам, а потом использовать array_reverse() и склеить снова.
$str = 'hello';
// echo implode('', array_reverse(explode('', $str)));
// Однако такой метод не работает, так как explode требует непустого delimiter
// Правильный ответ: нужно использовать str_split, а не explode. Либо использовать strrev()
echo implode('', array_reverse(str_split($str)));

// 8. Что будет результатом работы данного кода?
$a=0;
if($b=$a)
    echo "One";
else
    echo "Two";
// Мой ответ: выведет "Two", так как происходит присвоение $b нуля, который является falsy.
// Правильный ответ: совпадает с моим

// 9. Сгенерировать три случайных числа в диапазоне от 0 до 10. Если сумма этих чисел меньше 15, сгенерировать новую тройку.
// Мой ответ:
function generate()
{
    $n = 0;
    do {
        $a = rand(0, 10);
        $b = rand(0, 10);
        $c = rand(0, 10);
        $n++;
    } while ($a + $b + $c < 15);

    return [
        'a' => $a,
        'b' => $b,
        'c' => $c,
        'sum' => $a + $b + $c,
        'number of iterations' => $n,
    ];
}
var_dump(generate());
// Правильный ответ: совпадает с моим

// 10. Какое число выведет данный код?
$i = 10;
$i += ++$i + $i + $i++; // Оригинал: $i += ++i + $i + $i++;
echo $i;
// Конкретно данный код выведет ошибку, так как забыт $ перед i на второй строке.
// Если ее исправить, то выведет 43: 10 += 11 + 11 + 11
// Правильный ответ: 45: 12 += 11 + 11 + 11. Думал учесть, что левая сторона присвоения тоже измениться из-за инкремента, но не учел.

// 11. Что выведет приведенный ниже код?
$a = "1";
$a[$a] = "2";
echo $a;
// Мой вариант: выведет массив ['1' => '2']
// Правильный ответ: вывел "12". Очевидно произошла конкатенация, но затрудняюсь ответить почему.
