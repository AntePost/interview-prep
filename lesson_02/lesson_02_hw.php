<?php

// 1. Какие типы паттернов проектирования существуют?
// Мой ответ: порождающие (например абстрактная фабрика), структурные и архитектурные.
// Правильный ответ: порождающие (например абстрактная фабрика), 
// структурные (например адаптер) и поведенческие (например стратегия).

// 2. Как можно улучшить Singleton при помощи trait-ов?
// Мой ответ: не совсем понятен вопрос, одиночку можно сделать на трейтах, пример:
// https://github.com/AntePost/PHP-advanced/blob/master/lesson_08/traits/TSingleton.php
// Правильный ответ: не найден

// 3. Как реализуется паттерн Фабричный метод? В чем его отличие от паттерна Фабрика?
// Мой ответ: на память не вспомню. Из названия логично предположить, 
// что фабрика - это класс, который порождает другие объекты, 
// а фабричный метод - это метод в классе, который порождает другие объекты.
// Правильный ответ: фабричный метод реализуется путем создания абстрактного суперкласса с определенным интерфейсом, 
// чьи наследники реализуют абстрактный фабричный метод, имплементируя интерфейс определенным образом.
// Что касается отличия от паттерна фабрика, то в ней существует один единственный класс, 
// у которого есть несколько методов по созданию новых объектов.

// 4. Объясните назначение и применение магических методов __get, __set, __isset, __unset, __call и __callStatic. 
// Когда, как и почему их стоит использовать (или нет)?
// Мой ответ: эти методы определяют некоторые базовые действия при работе с классом. 
// Например __set определяет, что будет происходить при присвоении значения, 
// а __call - при вызове метода. Их можно переопределить, чтобы эти действия имели другое поведение.
// Привести реальный пример по памяти затрудняюсь.
// Правильный ответ: в общем я ответил правильно, но неправильно описал назначения методов. 
// __call и __set вызываются, когда происходит попытка обращения 
// к несуществующим или недоступным методам и свойствам соответственно.

// 5. Опишите несколько структур данных из стандартной библиотеки PHP (SPL). Приведите примеры использования.
// Мой ответ: точно их не помню, могу предположить, что там есть стэк, очередь, разные типы списков 
// (односвязанный, двусвязанный, XOR-список), деревья. Что касается примером использования, 
// то могу привести пример с использованием стэка для парсинга математических выражений вида 17 + 4 * (5 / 2) и вычисления их значения:
// https://github.com/AntePost/PHP-algo/pull/4/files#diff-a56dc99fb96bc858d070d2b795663294

// 6. Найдите все ошибки в коде:
/*
interface MyInt {
    public function funcI();
    private function funcP();
} 
class A {
    protected prop1;
    private prop2;

    function funcA(){
       return $this->prop2;
    }
}
class B extends A {
    function funcB(){
       return $this->prop1;
    }
}
class C extends B implements MyInt {
    function funcB(){
       return $this->prop1;
    }
    private function funcP(){
       return 123;
    }
}  
$b = new B();
$b->funcA();
$c = new C();
$c->funcI();
*/
// Мой ответ: 1. отсутствие $ на строках 44 и 45.
// 2. Не ошибка, но плохая практика: переопределение funcB в классе C без каких-либо изменений.
// 3. Класс C не реализует funcI, которую обязан реализовать по интерфейсу.
// 4. У функций funcA и funcB не указана область видимости.
// 5. На 67 строке вызов несуществующей функции.
// Исправленный вариант:
interface MyInt {
    public function funcI();
    function funcP();
} 
class A {
    protected $prop1;
    private $prop2;

    public function funcA(){
       return $this->prop2;
    }
}
class B extends A {
    private function funcB(){
       return $this->prop1;
    }
}
class C extends B implements MyInt {
    public function funcP(){
       return 123;
    }

    public function funcI() {
        return 321;
    }
}  
$b = new B();
$b->funcA();
$c = new C();
$c->funcI();
// Правильный ответ: в дополнение к моим ошибкам, 
// также неправильно указывать область видимости у funcP в интерфейсе и 
// и видимость реализации funcP должна быть публичной.